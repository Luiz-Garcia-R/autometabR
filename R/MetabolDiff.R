#' Differential Analysis for Metabolomics Data Using Limma
#'
#' @description
#' Performs differential analysis between experimental groups using the
#' `limma` workflow. The function extracts expression data from a
#' `metabolNorm` object, merges with metadata, builds a design matrix,
#' constructs a contrast, and returns (or auto-assigns) a `limma` results list
#' containing statistics for all metabolites.
#'
#' @details
#' This function is designed to work with objects produced by
#' `metabol.normalize()`, which store normalized intensities in
#' `normalized_data$expr_matrix` and optionally metadata in
#' `normalized_data$metadata`.
#'
#' If `metadata` is not provided explicitly, the function attempts to retrieve
#' it from the normalized object. Metadata must contain a `"Sample"` column and
#' a grouping column specified via `group_col`.
#'
#' The design matrix is constructed using one-hot encoding (`~ 0 + group`),
#' where groups are taken from `metadata[[group_col]]`. If no `contrast` is
#' specified and exactly two groups are present, the contrast is automatically
#' defined as `"Group2 - Group1"`. For more than two groups, a manual contrast
#' is required.
#'
#' By default, the updated `normalized_data` object (now containing
#' `$limma_results`) is auto-assigned back to the calling environment, mimicking
#' the behavior of workflows in packages like **limma** and **edgeR**.
#'
#' @param normalized_data A `metabolNorm` object generated by
#'   `metabol.normalize()`. Must contain at least `expr_matrix`, and optionally
#'   `metadata` and prior `limma_results`.
#' @param metadata Optional data frame containing sample metadata, including a
#'   `"Sample"` column and a grouping column. If omitted, the function will use
#'   `normalized_data$metadata` when available.
#' @param group_col Name of the column in metadata representing group labels.
#'   Default is `"Group"`.
#' @param contrast A character string specifying a contrast in the
#'   `limma::makeContrasts()` format (e.g., `"Treated - Control"`). If `NULL`
#'   and two groups exist, the contrast is generated automatically.
#' @param verbose Logical; whether to print informative messages during the run.
#'   Default is `TRUE`.
#' @param assign_result Logical; whether to assign the updated object (with
#'   `limma_results`) back to the caller environment. Default is `TRUE`.
#' @param assign_name Optional custom name to assign the object to. If `NULL`,
#'   the function attempts to infer the name of the input object.
#' @param envir Environment where the updated object will be assigned.
#'   Default is the parent frame.
#'
#' @return
#' If `assign_result = TRUE`, returns `invisible(NULL)` and assigns the modified
#' object back to the calling environment.
#' If `assign_result = FALSE`, returns the updated `normalized_data` object
#' containing:
#'
#' \itemize{
#'   \item `$limma_results$results` – data frame with `logFC`, `P.Value`,
#'     `adj.P.Val`, `t`, etc.
#'   \item `$limma_results$design` – design matrix used in the analysis.
#'   \item `$limma_results$contrast` – contrast string.
#'   \item `$limma_results$fit` – fitted `eBayes` model object.
#'   \item `$limma_results$metadata` – metadata matched to expression samples.
#'   \item `$limma_results$expr_used` – expression matrix used internally.
#' }
#'
#' @examples
#' \dontrun{
#' # Basic usage with two groups
#' metabol.diff(my_norm)
#'
#' # Explicit metadata and contrast
#' metabol.diff(
#'   normalized_data = my_norm,
#'   metadata = meta_df,
#'   group_col = "Condition",
#'   contrast = "Infected - Control"
#' )
#'
#' # Disable auto-assign and capture the output
#' res <- metabol.diff(my_norm, assign_result = FALSE)
#' }
#'
#' @importFrom limma lmFit contrasts.fit eBayes topTable makeContrasts
#' @importFrom stats model.matrix
#'
#' @export

metabol.diff <- function(normalized_data,
                         metadata = NULL,
                         group_col = "Group",
                         contrast = NULL,
                         verbose = TRUE,
                         assign_result = TRUE,
                         assign_name = NULL,
                         envir = parent.frame()) {

  # ------------------------------------------------------------
  # 0) Dependencies
  # ------------------------------------------------------------
  pkgs <- c("limma")
  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
  if (length(missing_pkgs) > 0) {
    stop("Install required packages: ", paste(missing_pkgs, collapse = ", "))
  }

  # ------------------------------------------------------------
  # 1) Detect caller name for auto-assign
  # ------------------------------------------------------------
  caller_name <- NULL
  try({
    caller_name_tmp <- deparse(substitute(normalized_data))
    if (!grepl("\\(|\\$|\\[", caller_name_tmp)) {
      caller_name <- caller_name_tmp
    }
  }, silent = TRUE)

  if (!is.null(assign_name)) {
    caller_name <- assign_name
  }

  # ------------------------------------------------------------
  # 2) Input checks
  # ------------------------------------------------------------
  if (!inherits(normalized_data, "metabolNorm")) {
    stop("Input must be a metabolNorm object (output of metabol.normalize()).")
  }

  if (!"expr_matrix" %in% names(normalized_data)) {
    stop("normalized_data must contain $expr_matrix.")
  }

  # ------------------------------------------------------------
  # 3) Metadata fallback
  # ------------------------------------------------------------
  if (is.null(metadata)) {
    if (!"metadata" %in% names(normalized_data)) {
      stop("metadata not provided and not found inside normalized_data$metadata.")
    }
    metadata <- normalized_data$metadata
    if (verbose) {
      message("Using metadata stored inside normalized_data.")
    }
  } else {
    if (verbose) {
      message("Using metadata provided explicitly by the user.")
    }
  }

  # ------------------------------------------------------------
  # 4) Extract expression
  # ------------------------------------------------------------
  expr_df <- normalized_data$expr_matrix

  if ("Sample" %in% colnames(expr_df)) {
    samples <- as.character(expr_df[["Sample"]])
    expr_df <- expr_df[, colnames(expr_df) != "Sample", drop = FALSE]
  } else {
    samples <- colnames(expr_df)
  }

  expr_mat <- t(as.matrix(expr_df))
  colnames(expr_mat) <- samples

  # ------------------------------------------------------------
  # 5) Match metadata to expression samples
  # ------------------------------------------------------------
  if (!"Sample" %in% colnames(metadata)) {
    stop("metadata must contain a column named 'Sample' with sample IDs.")
  }

  metadata2 <- metadata[match(colnames(expr_mat), metadata$Sample), , drop = FALSE]

  if (any(is.na(metadata2$Sample))) {
    stop("Metadata samples do not match expression data. Check sample names and ordering.")
  }

  # ------------------------------------------------------------
  # 6) Design matrix
  # ------------------------------------------------------------
  group <- as.factor(metadata2[[group_col]])
  if (verbose) {
    message("Groups detected: ", paste(levels(group), collapse = ", "))
  }

  design <- model.matrix(~ 0 + group)
  colnames(design) <- levels(group)

  # ------------------------------------------------------------
  # 7) Contrast
  # ------------------------------------------------------------
  if (is.null(contrast)) {
    if (length(levels(group)) != 2) {
      stop("For >2 groups, provide a contrast such as 'G2 - G1'.")
    }
    levs <- levels(group)
    contrast <- paste0(levs[2], " - ", levs[1])
  }

  if (verbose) {
    message("Contrast used: ", contrast)
  }

  contrast_matrix <- limma::makeContrasts(
    contrasts = contrast,
    levels = design
  )

  # ------------------------------------------------------------
  # 8) Limma pipeline
  # ------------------------------------------------------------
  fit <- limma::lmFit(expr_mat, design)
  fit2 <- limma::contrasts.fit(fit, contrast_matrix)
  fit2 <- limma::eBayes(fit2)

  results <- limma::topTable(fit2, number = Inf, sort.by = "none")

  results$Metabolite <- rownames(results)
  results <- results[, c("Metabolite", "logFC", "AveExpr", "t",
                         "P.Value", "adj.P.Val", "B")]

  # ------------------------------------------------------------
  # 9) Attach results to object
  # ------------------------------------------------------------
  normalized_data$limma_results <- list(
    results = results,
    design = design,
    contrast = contrast,
    fit = fit2,
    metadata = metadata2,
    expr_used = expr_mat
  )

  # ------------------------------------------------------------
  # 10) Auto-assign updated object in parent environment
  # ------------------------------------------------------------
  if (isTRUE(assign_result) && !is.null(caller_name)) {
    base::assign(caller_name, normalized_data, envir = envir)
    if (verbose) {
      message("Differential analysis stored in '", caller_name, "$limma_results'.")
    }
    return(invisible(NULL))
  }

  if (isTRUE(assign_result) && is.null(caller_name) && verbose) {
    message("Could not determine object name to auto-assign; returning object instead.")
  }

  normalized_data
}
