#' Dimensionality Reduction for Metabolomics Data
#'
#' Performs PCA, UMAP, and PLS-DA on a `metabolNorm` object.
#' Automatically extracts both expression matrix and metadata from the object.
#' Returns plots and a structured list including VIP scores from PLS-DA.
#'
#' @param normalized_data A `metabolNorm` object generated by `metabol.normalization()`.
#' @param group_col Character. Column in metadata defining sample groups.
#' @param ncomp_plsda Integer. Number of PLS-DA components. Default = 2.
#' @param n_neighbors Integer. Number of neighbors for UMAP.
#' If NULL, defaults to half of the number of samples.
#' @param cross_val Integer. Number of folds for PLS-DA cross-validation. Default = 5.
#' @param plot Logical. Whether to plot PCA, UMAP, and PLS-DA figures. Default = TRUE.
#' @param verbose Logical. Whether to display messages during execution. Default = TRUE.
#' @param assign_result Logical. Whether to assign the result back to the given environment. Default = TRUE.
#' @param assign_name Character. Name of the object to be assigned.
#' If NULL, uses the name of the input object automatically.
#' @param envir Environment where the object will be assigned. Default = parent.frame().
#'
#' @return Invisibly returns the updated `metabolNorm` object containing:
#' \describe{
#'   \item{expr_matrix}{Numeric matrix used for dimensionality reduction.}
#'   \item{metadata}{Metadata aligned to expression rows.}
#'   \item{dimred_obj}{A list with:
#'       \describe{
#'         \item{pca_res}{PCA model object from `stats::prcomp`.}
#'         \item{umap_res}{UMAP result object from `umap::umap`.}
#'         \item{plsda_res}{PLS-DA model object from `mixOmics::plsda`.}
#'         \item{plsda_acc}{Cross-validated accuracy estimate.}
#'       }}
#'   \item{vip_scores}{Vector of VIP scores from the PLS-DA model.}
#' }
#'
#' @examples
#' \dontrun{
#' # Minimal example
#' set.seed(123)
#' expr_mat <- matrix(rnorm(100), nrow = 20, ncol = 5)
#' rownames(expr_mat) <- paste0("S", 1:20)
#' colnames(expr_mat) <- paste0("Met", 1:5)
#'
#' meta$Sample <- factor(meta$Sample)
#' meta <- data.frame(
#'  Sample = paste0("S", 1:20),
#'  Group  = rep(c("A","B"), each = 10)
#' )
#'
#' res <- metabol.dimred(expr_mat, metadata = meta, cross_val = 3)
#' }
#' @references
#' Jolliffe IT (2002). Principal Component Analysis. 2nd edition. Springer Series in Statistics.
#' Barker M, Rayens W (2003). Partial least squares for discrimination. \emph{Journal of Chemometrics}, 17:166–173. <doi:10.1002/cem.785>
#' McInnes L, Healy J, Melville J (2018). UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. \emph{arXiv:1802.03426}.
#'
#' @export

metabol.dimred <- function(normalized_data,
                           group_col = "Group",
                           ncomp_plsda = 2,
                           n_neighbors = NULL,
                           cross_val = 5,
                           plot = TRUE,
                           verbose = TRUE,
                           assign_result = TRUE,
                           assign_name = "normalized_data",
                           envir = parent.frame()) {

  # ------------------------------------------------------------
  # 0) Packages
  # ------------------------------------------------------------
  pkgs <- c("ggplot2", "umap", "mixOmics")
  missing <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
  if (length(missing) > 0) {
    stop("Install required packages: ", paste(missing, collapse = ", "))
  }

  # ------------------------------------------------------------
  # 1) Validate input
  # ------------------------------------------------------------
  if (!inherits(normalized_data, "metabolNorm")) {
    stop("Input must be a 'metabolNorm' object.")
  }

  if (!is.list(normalized_data) || is.null(normalized_data$expr_matrix)) {
    stop("normalized_data must contain $expr_matrix (output of metabol.normalize()).")
  }

  expr_df <- normalized_data$expr_matrix
  if (!"Sample" %in% colnames(expr_df)) {
    stop("expr_matrix must contain a 'Sample' column.")
  }

  if (!"metadata" %in% names(normalized_data) || is.null(normalized_data$metadata)) {
    stop("normalized_data must contain $metadata (output of metabol.normalize()).")
  }

  metadata <- normalized_data$metadata
  if (!"Sample" %in% colnames(metadata)) {
    stop("metadata must contain a 'Sample' column.")
  }
  if (!group_col %in% colnames(metadata)) {
    stop("Column '", group_col, "' not found in metadata.")
  }

  # ------------------------------------------------------------
  # 2) Prepare matrices
  # ------------------------------------------------------------
  samples <- as.character(expr_df[["Sample"]])
  mat <- as.matrix(expr_df[, setdiff(colnames(expr_df), "Sample"), drop = FALSE])
  storage.mode(mat) <- "numeric"

  metadata2 <- metadata[match(samples, metadata$Sample), , drop = FALSE]
  if (any(is.na(metadata2$Sample))) {
    stop("Sample names in expr_matrix do not match metadata$Sample.")
  }

  groups <- factor(metadata2[[group_col]])

  # ------------------------------------------------------------
  # 3) PCA
  # ------------------------------------------------------------
  if (verbose) message("Running PCA...")

  pca_res <- stats::prcomp(mat, center = TRUE, scale. = TRUE)
  var_expl <- pca_res$sdev^2 / sum(pca_res$sdev^2)

  df_pca <- data.frame(
    PC1 = pca_res$x[, 1],
    PC2 = pca_res$x[, 2],
    Group = groups,
    Sample = samples,
    stringsAsFactors = FALSE
  )

  p_pca <- ggplot2::ggplot(df_pca, ggplot2::aes(x = PC1, y = PC2, color = Group)) +
    ggplot2::geom_point(size = 3, alpha = 0.85) +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "PCA Projection",
      x = paste0("PC1 (", round(var_expl[1] * 100, 1), "%)"),
      y = paste0("PC2 (", round(var_expl[2] * 100, 1), "%)")
    )

  # ------------------------------------------------------------
  # 4) UMAP
  # ------------------------------------------------------------
  if (verbose) message("Running UMAP...")

  n_samples <- nrow(mat)
  if (is.null(n_neighbors) ||
      !is.numeric(n_neighbors) ||
      n_neighbors >= n_samples) {
    n_neighbors <- max(2, floor(n_samples / 2))
  }

  if (verbose) {
    message("UMAP n_neighbors = ", n_neighbors)
  }

  umap_res <- umap::umap(mat, n_neighbors = n_neighbors)

  df_umap <- data.frame(
    UMAP1 = umap_res$layout[, 1],
    UMAP2 = umap_res$layout[, 2],
    Group = groups,
    Sample = samples,
    stringsAsFactors = FALSE
  )

  p_umap <- ggplot2::ggplot(df_umap, ggplot2::aes(x = UMAP1, y = UMAP2, color = Group)) +
    ggplot2::geom_point(size = 3, alpha = 0.85) +
    ggplot2::theme_minimal() +
    ggplot2::labs(title = "UMAP Projection")

  # ------------------------------------------------------------
  # 5) PLS-DA
  # ------------------------------------------------------------
  if (verbose) message("Running PLS-DA...")

  plsda_res <- mixOmics::plsda(mat, groups, ncomp = ncomp_plsda)

  comp2_vec <- if (ncomp_plsda >= 2) plsda_res$variates$X[, 2] else rep(0, nrow(mat))

  df_plsda <- data.frame(
    Comp1 = plsda_res$variates$X[, 1],
    Comp2 = comp2_vec,
    Group = groups,
    Sample = samples,
    stringsAsFactors = FALSE
  )

  acc <- NA_real_
  set.seed(123)

  cv_res <- tryCatch(
    {
      suppressWarnings(
        mixOmics::perf(
          plsda_res,
          validation = "Mfold",
          folds = cross_val,
          progressBar = FALSE
        )
      )
    },
    error = function(e) NULL
  )

  if (!is.null(cv_res)) {
    if (!is.null(cv_res$error.rate$overall)) {
      acc <- mean(cv_res$error.rate$overall, na.rm = TRUE)
    } else if (!is.null(cv_res$error.rate)) {
      acc <- mean(unlist(cv_res$error.rate), na.rm = TRUE)
    }
    acc <- round(acc, 3)
  }

  p_plsda <- ggplot2::ggplot(df_plsda, ggplot2::aes(x = Comp1, y = Comp2, color = Group)) +
    ggplot2::geom_point(size = 3, alpha = 0.85) +
    ggplot2::stat_ellipse(linetype = 2, na.rm = TRUE) +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "PLS-DA",
      subtitle = paste("Accuracy:", acc),
      x = "Component 1",
      y = "Component 2"
    )

  # ------------------------------------------------------------
  # 6) Optional plotting
  # ------------------------------------------------------------
  if (isTRUE(plot)) {
    print(p_pca)
    print(p_umap)
    print(p_plsda)
  }

  # ------------------------------------------------------------
  # 7) Build dimred_obj and attach
  # ------------------------------------------------------------
  normalized_data$dimred_obj <- list(
    expr_matrix = mat,
    metadata = metadata,
    res_dimred = list(
      pca_res = pca_res,
      umap_res = umap_res,
      plsda_res = plsda_res,
      plsda_acc = acc,
      vip_scores = mixOmics::vip(plsda_res)
    )
  )

  if (verbose) {
    message("Dimensionality reduction results saved at $dimred_obj.")
  }

  # ------------------------------------------------------------
  # 8) Auto-assign (CRAN-safe version)
  # ------------------------------------------------------------
  if (is.null(assign_name)) {
    # No explicit assign_name → infer from input
    inferred <- tryCatch(deparse(substitute(normalized_data)), error = function(e) NULL)
    if (!is.null(inferred) && isTRUE(assign_result)) {
      base::assign(inferred, normalized_data, envir = envir)
      return(invisible(NULL))
    }
  } else {
    # assign_name explicitly provided
    if (isTRUE(assign_result)) {
      base::assign(assign_name, normalized_data, envir = envir)
      return(invisible(NULL))
    }
  }

  invisible(normalized_data)
}
